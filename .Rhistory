# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}
# if all streams are selected, but no report citations are wanted, the final index is the complement of the report index
}else{
if(reports == "N"){
report_idx = grep("report", lines[ref_idx]) # bug: we actually want the complement of this to remove them. but we need to keep this to keep the reports.
final_idx = setdiff(1:length(ref_idx), report_idx)
}
}
if(exists("report_idx") & !exists("final_idx")){final_idx = report_idx}
# if we have made a new index (ie reports != "Y" or streams != "all") then remove the unwanted lines
if(exists("final_idx")){
if(!is.null(final_idx)){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}
}
### write the file
writeLines(lines, outFile)
if(i != selected_files[length(selected_files)]){writeLines("", outFile)}
}
close(outFile)
### print a message if some EXPOCODES are not matched to files.
if(any(missing)){print(paste("There are no BibTEX files in BIOMATE for the following voyages:", paste(EXPOCODES[missing], collapse = ", "), sep = " "))}
}
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
export_ref <- function(EXPOCODES = "all", stream = "all", path_out = "./", reports = "Y"){
# direct to citation files
meta_path = "./Rpackage/data/citations"
file_names = list.files(meta_path)
# select files besed on user-defined EXPOCODES
if(any(EXPOCODES != "all")){
EX = unlist(strsplit(file_names,".bib"))
check = lapply(EXPOCODES, function(x){match(x, EX)})
missing = is.na(check)
selected_files = file_names[unlist(check[!is.na(check)])]
}else{selected_files = file_names}
# compile citations into one BibTEX file for user
outName = file.path(path_out,"BIO-MATE_references.bib")
if(file.exists(outName)){file.remove(outName)}
outFile <- file(outName, "w")
for (i in selected_files){
lines <- readLines(file.path(meta_path,i))
nlines = length(lines)
### remove unwanted BIO-MATE data streams and reports
# create a reference index for the start of each reference using the @ symbol
ref_idx = grep("@", lines)
# get index of reports citations if required
if(reports == "Y"){
report_idx = grep("report", lines[ref_idx])
if(length(report_idx) == 0){rm(report_idx)}
}
# get index of perticular data stream citations if required
if(stream != "all"){
## change prof to ctd (mismatch in references)
#if(any(grepl("PROF", stream, ignore.case = T))){stream[grep("PROF", stream, ignore.case = T)] = "CTD"}
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
# for now we dont care if a citation is missing for a stream. When the metadata table is complete we can check data existance against citation existance
# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}
# if all streams are selected, but no report citations are wanted, the final index is the complement of the report index
}else{
if(reports == "N"){
report_idx = grep("report", lines[ref_idx]) # bug: we actually want the complement of this to remove them. but we need to keep this to keep the reports.
final_idx = setdiff(1:length(ref_idx), report_idx)
}
}
if(reports == "Y" & !exists("final_idx")){final_idx = report_idx}
# if we have made a new index (ie reports != "Y" or streams != "all") then remove the unwanted lines
if(exists("final_idx")){
if(!is.null(final_idx)){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}
rm(keep_lines, final_idx)
if(exists("report_idx")){rm(report_idx)}
if(exists("stream_idx")){rm(stream_idx)}
}
### write the file
writeLines(lines, outFile)
if(i != selected_files[length(selected_files)]){writeLines("", outFile)}
rm(lines, nlines, ref_idx, keep_lines, report_idx, final_idx)
}
close(outFile)
### print a message if some EXPOCODES are not matched to files.
if(any(missing)){print(paste("There are no BibTEX files in BIOMATE for the following voyages:", paste(EXPOCODES[missing], collapse = ", "), sep = " "))}
}
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
export_ref <- function(EXPOCODES = "all", stream = "all", path_out = "./", reports = "Y"){
# direct to citation files
meta_path = "./Rpackage/data/citations"
file_names = list.files(meta_path)
# select files besed on user-defined EXPOCODES
if(any(EXPOCODES != "all")){
EX = unlist(strsplit(file_names,".bib"))
check = lapply(EXPOCODES, function(x){match(x, EX)})
missing = is.na(check)
selected_files = file_names[unlist(check[!is.na(check)])]
}else{selected_files = file_names}
# compile citations into one BibTEX file for user
outName = file.path(path_out,"BIO-MATE_references.bib")
if(file.exists(outName)){file.remove(outName)}
outFile <- file(outName, "w")
for (i in selected_files){
lines <- readLines(file.path(meta_path,i))
nlines = length(lines)
### remove unwanted BIO-MATE data streams and reports
# create a reference index for the start of each reference using the @ symbol
ref_idx = grep("@", lines)
# get index of reports citations if required
if(reports == "Y"){
report_idx = grep("report", lines[ref_idx])
if(length(report_idx) == 0){rm(report_idx)}
}
# get index of perticular data stream citations if required
if(stream != "all"){
## change prof to ctd (mismatch in references)
#if(any(grepl("PROF", stream, ignore.case = T))){stream[grep("PROF", stream, ignore.case = T)] = "CTD"}
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
# for now we dont care if a citation is missing for a stream. When the metadata table is complete we can check data existance against citation existance
# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}
# if all streams are selected, but no report citations are wanted, the final index is the complement of the report index
}else{
if(reports == "N"){
report_idx = grep("report", lines[ref_idx]) # bug: we actually want the complement of this to remove them. but we need to keep this to keep the reports.
final_idx = setdiff(1:length(ref_idx), report_idx)
}
}
if(reports == "Y" & !exists("final_idx")){final_idx = report_idx}
# if we have made a new index (ie reports != "Y" or streams != "all") then remove the unwanted lines
if(exists("final_idx")){
if(!is.null(final_idx)){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}
rm(keep_lines, final_idx)
if(exists("report_idx")){rm(report_idx)}
if(exists("stream_idx")){rm(stream_idx)}
}
### write the file
writeLines(lines, outFile)
if(i != selected_files[length(selected_files)]){writeLines("", outFile)}
rm(lines, nlines, ref_idx)
}
close(outFile)
### print a message if some EXPOCODES are not matched to files.
if(any(missing)){print(paste("There are no BibTEX files in BIOMATE for the following voyages:", paste(EXPOCODES[missing], collapse = ", "), sep = " "))}
}
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
EXPOCODES = c("09AR19910103", "09SS19961120")
stream = "PROF"
reports = "N"
path_out = "./"
# direct to citation files
meta_path = "./Rpackage/data/citations"
file_names = list.files(meta_path)
# select files besed on user-defined EXPOCODES
if(any(EXPOCODES != "all")){
EX = unlist(strsplit(file_names,".bib"))
check = lapply(EXPOCODES, function(x){match(x, EX)})
missing = is.na(check)
selected_files = file_names[unlist(check[!is.na(check)])]
}else{selected_files = file_names}
# compile citations into one BibTEX file for user
outName = file.path(path_out,"BIO-MATE_references.bib")
if(file.exists(outName)){file.remove(outName)}
outFile <- file(outName, "w")
i = selected_files[1]
lines <- readLines(file.path(meta_path,i))
nlines = length(lines)
### remove unwanted BIO-MATE data streams and reports
# create a reference index for the start of each reference using the @ symbol
ref_idx = grep("@", lines)
# get index of reports citations if required
if(reports == "Y"){
report_idx = grep("report", lines[ref_idx])
if(length(report_idx) == 0){rm(report_idx)}
}
stream != "all"
## change prof to ctd (mismatch in references)
#if(any(grepl("PROF", stream, ignore.case = T))){stream[grep("PROF", stream, ignore.case = T)] = "CTD"}
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
# for now we dont care if a citation is missing for a stream. When the metadata table is complete we can check data existance against citation existance
# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}else{final_idx = stream_idx}
if(reports == "Y" & !exists("final_idx")){final_idx = report_idx}
# if we have made a new index (ie reports != "Y" or streams != "all") then remove the unwanted lines
if(exists("final_idx")){
if(!is.null(final_idx)){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}else{print(paste("No references selected for", unlist(strsplit(i,".bib"))))
next}
rm(keep_lines, final_idx)
if(exists("report_idx")){rm(report_idx)}
if(exists("stream_idx")){rm(stream_idx)}
}
lines <- readLines(file.path(meta_path,i))
nlines = length(lines)
### remove unwanted BIO-MATE data streams and reports
# create a reference index for the start of each reference using the @ symbol
ref_idx = grep("@", lines)
# get index of reports citations if required
if(reports == "Y"){
report_idx = grep("report", lines[ref_idx])
if(length(report_idx) == 0){rm(report_idx)}
}
# get index of perticular data stream citations if required
if(stream != "all"){
## change prof to ctd (mismatch in references)
#if(any(grepl("PROF", stream, ignore.case = T))){stream[grep("PROF", stream, ignore.case = T)] = "CTD"}
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
# for now we dont care if a citation is missing for a stream. When the metadata table is complete we can check data existance against citation existance
# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}else{final_idx = stream_idx}
# if all streams are selected, but no report citations are wanted, the final index is the complement of the report index
}else{
if(reports == "N"){
report_idx = grep("report", lines[ref_idx])
final_idx = setdiff(1:length(ref_idx), report_idx)
}
}
if(reports == "Y" & !exists("final_idx")){final_idx = report_idx}
exists("final_idx"
)
!is.null(final_idx)
length(final_idx) > 0
if(length(final_idx) > 0){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}else{print(paste("No references selected for", unlist(strsplit(i,".bib"))))
next}
rm(keep_lines, final_idx)
if(exists("report_idx")){rm(report_idx)}
if(exists("stream_idx")){rm(stream_idx)}
rm(lines, nlines, ref_idx)
for (i in selected_files){
lines <- readLines(file.path(meta_path,i))
nlines = length(lines)
### remove unwanted BIO-MATE data streams and reports
# create a reference index for the start of each reference using the @ symbol
ref_idx = grep("@", lines)
# get index of reports citations if required
if(reports == "Y"){
report_idx = grep("report", lines[ref_idx])
if(length(report_idx) == 0){rm(report_idx)}
}
# get index of perticular data stream citations if required
if(stream != "all"){
## change prof to ctd (mismatch in references)
#if(any(grepl("PROF", stream, ignore.case = T))){stream[grep("PROF", stream, ignore.case = T)] = "CTD"}
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
# for now we dont care if a citation is missing for a stream. When the metadata table is complete we can check data existance against citation existance
# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}else{final_idx = stream_idx}
# if all streams are selected, but no report citations are wanted, the final index is the complement of the report index
}else{
if(reports == "N"){
report_idx = grep("report", lines[ref_idx])
final_idx = setdiff(1:length(ref_idx), report_idx)
}
}
if(reports == "Y" & !exists("final_idx")){final_idx = report_idx}
# if we have made a new index (ie reports != "Y" or streams != "all") then remove the unwanted lines
if(exists("final_idx")){
if(length(final_idx) > 0){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}else{print(paste("No references selected for", unlist(strsplit(i,".bib"))))
next}
rm(keep_lines, final_idx)
if(exists("report_idx")){rm(report_idx)}
if(exists("stream_idx")){rm(stream_idx)}
}
### write the file
writeLines(lines, outFile)
if(i != selected_files[length(selected_files)]){writeLines("", outFile)}
rm(lines, nlines, ref_idx)
}
close(outFile)
export_ref <- function(EXPOCODES = "all", stream = "all", path_out = "./", reports = "Y"){
# direct to citation files
meta_path = "./Rpackage/data/citations"
file_names = list.files(meta_path)
# select files besed on user-defined EXPOCODES
if(any(EXPOCODES != "all")){
EX = unlist(strsplit(file_names,".bib"))
check = lapply(EXPOCODES, function(x){match(x, EX)})
missing = is.na(check)
selected_files = file_names[unlist(check[!is.na(check)])]
}else{selected_files = file_names}
# compile citations into one BibTEX file for user
outName = file.path(path_out,"BIO-MATE_references.bib")
if(file.exists(outName)){file.remove(outName)}
outFile <- file(outName, "w")
for (i in selected_files){
lines <- readLines(file.path(meta_path,i))
nlines = length(lines)
### remove unwanted BIO-MATE data streams and reports
# create a reference index for the start of each reference using the @ symbol
ref_idx = grep("@", lines)
# get index of reports citations if required
if(reports == "Y"){
report_idx = grep("report", lines[ref_idx])
if(length(report_idx) == 0){rm(report_idx)}
}
# get index of perticular data stream citations if required
if(stream != "all"){
## change prof to ctd (mismatch in references)
#if(any(grepl("PROF", stream, ignore.case = T))){stream[grep("PROF", stream, ignore.case = T)] = "CTD"}
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
# for now we dont care if a citation is missing for a stream. When the metadata table is complete we can check data existance against citation existance
# cobine report idx and select stream idx if needed
if(exists("report_idx")){final_idx = c(report_idx, stream_idx)}else{final_idx = stream_idx}
# if all streams are selected, but no report citations are wanted, the final index is the complement of the report index
}else{
if(reports == "N"){
report_idx = grep("report", lines[ref_idx])
final_idx = setdiff(1:length(ref_idx), report_idx)
}
}
if(reports == "Y" & !exists("final_idx")){final_idx = report_idx}
# if we have made a new index (ie reports != "Y" or streams != "all") then remove the unwanted lines
if(exists("final_idx")){
if(length(final_idx) > 0){
final_idx = final_idx[order(final_idx, decreasing = T)]
keep_lines = NULL
for(r in final_idx){
if(r == length(ref_idx)){
keep_lines = c(lines[ref_idx[r]:nlines], keep_lines)
}else{
keep_lines = c(lines[ref_idx[r]:(ref_idx[r+1]-1)], keep_lines)
}
}
lines = keep_lines
}else{print(paste("No references selected for", unlist(strsplit(i,".bib"))))
next}
rm(keep_lines, final_idx)
if(exists("report_idx")){rm(report_idx)}
if(exists("stream_idx")){rm(stream_idx)}
}
### write the file
writeLines(lines, outFile)
if(i != selected_files[length(selected_files)]){writeLines("", outFile)}
rm(lines, nlines, ref_idx)
}
close(outFile)
### print a message if some EXPOCODES are not matched to files.
if(any(missing)){print(paste("There are no BibTEX files in BIOMATE for the following voyages:", paste(EXPOCODES[missing], collapse = ", "), sep = " "))}
}
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = "PROF",  reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = c("PROF","UWY"),  reports = "N")
export_ref(EXPOCODES = c("09AR19910103", "09SS19961120"), stream = c("PROF","UWY"),  reports = "Y")
# change all _ctd to _prof in references
# direct to citation files
meta_path = "./Rpackage/data/citations"
file_names = list.files(meta_path)
i = "09AR19910103.bib"
lines <- readLines(file.path(meta_path,i))
ref_idx = grep("@", lines)
stream_idx = unlist(lapply(stream, function(x){grep(x,lines[ref_idx], ignore.case = T)}))
stream_idx = unlist(lapply("ctd", function(x){grep(x,lines[ref_idx], ignore.case = T)}))
ctd_idx = unlist(lapply("ctd", function(x){grep(x,lines[ref_idx], ignore.case = T)}))
if(length(ctd_idx) > 0){
for(j in ctd_idx){
lines[ref_idx[j]] = str_replace(lines[ref_idx[j]], "_ctd", "_prof")
}
}
# change all _ctd to _prof in references
# direct to citation files
library(stringr)
if(length(ctd_idx) > 0){
for(j in ctd_idx){
lines[ref_idx[j]] = str_replace(lines[ref_idx[j]], "_ctd", "_prof")
}
}
lines
lines <- readLines(file.path(meta_path,i))
lines
# Overwrite the file
file.remove(i)
# Overwrite the file
file.remove(file.path(meta_path, i))
# Overwrite the file
OutName = file.path(meta_path, i)
file.remove(OutName)
outFile <- file(OutName, "w")
writeLines(lines, outFile)
close(outFile)
OutName
lines
lines <- readLines(file.path(meta_path,i))
ref_idx = grep("@", lines)
ctd_idx = unlist(lapply("ctd", function(x){grep(x,lines[ref_idx], ignore.case = T)}))
if(length(ctd_idx) > 0){
for(j in ctd_idx){
lines[ref_idx[j]] = str_replace(lines[ref_idx[j]], "_ctd", "_prof")
}
}
lines
ref_idx[j]
lines[ref_idx[j]]
lines
length(ctd_idx) > 0
# Overwrite the file
OutName = file.path(meta_path, i)
file.remove(OutName)
outFile <- file(OutName, "w")
writeLines(lines, outFile)
close(outFile)
# change all _ctd to _prof in references
# direct to citation files
library(stringr)
meta_path = "./Rpackage/data/citations"
file_names = list.files(meta_path)
for(i in file_names){
lines <- readLines(file.path(meta_path,i))
ref_idx = grep("@", lines)
ctd_idx = unlist(lapply("ctd", function(x){grep(x,lines[ref_idx], ignore.case = T)}))
if(length(ctd_idx) > 0){
for(j in ctd_idx){
lines[ref_idx[j]] = str_replace(lines[ref_idx[j]], "_ctd", "_prof")
}
}
# Overwrite the file
OutName = file.path(meta_path, i)
file.remove(OutName)
outFile <- file(OutName, "w")
writeLines(lines, outFile)
close(outFile)
}
warnings()
library(dplyr)
library(tools)
library(data.table)
library(ncdf4)
library(readr)
library(geosphere)
library(stringi)
library(tidyr)
source(file.path("./src","Marlin_SS_split_CTD.R"))
source(file.path("./src","split_compiled_delim_file.R"))
files = c("MNF_FR199710_ctd_trawler.csv",
"O&A_SS199603_ctd_trawler.csv",
"MNF_IN2016_V01_ctd_trawler.csv",
"MNF_IN2016_V02_ctd_trawler.csv",
"MNF_IN2016_V03_ctd_trawler.csv",
"MNF_IN2018_V01_ctd_trawler.csv")
expos = c("09FA19971125",
"09SS19960513",
"096U20160107",
"096U20160314",
"096U20160426",
"096U20180110"
)
for(ex in 1:length(expos)){
split_compiled_delim_file(path = file.path("E:/Data_downloads/Marlin",expos[ex]), file_name = files[ex], delim = ",",expo_split = F,station_split = T, station_var_name = "STATION")
}
