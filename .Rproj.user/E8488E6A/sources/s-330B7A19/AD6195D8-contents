---
title: "BIOMATE Analysis"
author: "K Baldry"
date: "10 August 2021"
output: html_document
---

```{r}
library(BIOMATE)
library(seacarb)
source("./src/compile_pigment_data.R")
source("C:/Users/kabaldry/OneDrive - University of Tasmania/Documents/PhD/Ch4_SCM/SRC/Water structure clustering/filters.R")
source("C:/Users/kabaldry/OneDrive - University of Tasmania/Documents/PhD/Ch4_SCM/SRC/Water structure clustering/MLD_calcs.R")
imported_meta = read.csv("./product_data/supporting_information/Metadata/EXPOCODE_metadata.csv")
```

# by pigment profile attributes table 
# compile pigment data
```{r setup, include=FALSE}
data_path = "C:/Users/kabaldry/OneDrive - University of Tasmania/Documents/Projects/BIO-MATE/reformatted_data"
pig_data = compile_pigments(path = data_path)

# expocodes for PIG data
pig_path = file.path(data_path,"pigments")
pig_files = list.files(pig_path, pattern = "*.csv")
pig_expos = unique(substr(pig_files,1,12))
# expocodes for PROF data
prof_path = file.path(data_path,"profiling_sensors")
prof_files = list.files(prof_path, pattern = "*.csv")
prof_expos = unique(substr(prof_files,1,12))
# all expocodes with files
all_expos = unique(c(prof_expos,pig_expos))

```


# by PROF profile attributes table
# QA prof against OISST or another product
```{r}
CTD_df = data.frame("CTD_ID" = character(),"DATE" = character(), "TIME_s" = as.POSIXct(character()), "TIME_b"= as.POSIXct(character()), "TIME_e"= as.POSIXct(character()), "LAT"=numeric(), "LON" = numeric(),"LAT_b" = numeric(), "LON_b" = numeric(), "LAT_e" = numeric(), "LON_e" = numeric(), "T_diff_b" =  as.difftime(character()), "T_diff_e" = as.difftime(character()), "POS_diff_b" = numeric(), "POS_diff_e" = numeric(), "BOT_DEPTH" = numeric(),"DEPTH_s" = numeric(), "CTDSAL_s" = numeric(), "CTDTEMP_s" = numeric(), "CTDSAL_10" = numeric(), "CTDTEMP_10" = numeric(), "MLD" = numeric(), "MLD_FLAG" = numeric())

 for(ctd in prof_files){
      ctd_file = file.path(prof_path,ctd)

      time_s = NA
      time_b = NA
      time_e = NA
      # open file and read relevent lines
      f <- file(ctd_file, open = "r" )
      n = 0
      while( TRUE ){
        line <- readLines( f, 1L ,skipNul = T)
        n = n+1
        if( grepl( "DATE =", line ) ){
         date <- trimws(sub("DATE =", "", line ))
        }
        if( grepl( "CTD_START_TIME =", line ) ){
          t_line = line
          time_s<- trimws(sub("UTC","",sub("CTD_START_TIME =", "", line )))

        }
        if( grepl( "CTD_BOTTOM_TIME =", line ) ){
          time_b <- trimws(sub("UTC","",sub( "CTD_BOTTOM_TIME =", "", line )))

        }
        if( grepl( "CTD_END_TIME =", line ) ){
          time_e <- trimws(sub("UTC","",sub( "CTD_END_TIME =", "", line )))

        }
        if( grepl( "CTD_START_LATITUDE =", line ) ){
          lat <- as.numeric(sub("CTD_START_LATITUDE =", "", line ))
        }
        if( grepl( "CTD_START_LONGITUDE =", line ) ){
          lon <- as.numeric(sub("CTD_START_LONGITUDE =", "", line ))
        }
        if( grepl( "CTD_BOTTOM_LATITUDE =", line ) ){
          lat_b <- as.numeric(sub("CTD_BOTTOM_LATITUDE =", "", line ))
        }
        if( grepl( "CTD_BOTTOM_LONGITUDE =", line ) ){
          lon_b <- as.numeric(sub("CTD_BOTTOM_LONGITUDE =", "", line ))
        }
        if( grepl( "CTD_END_LATITUDE =", line ) ){
          lat_e <- as.numeric(sub("CTD_END_LATITUDE =", "", line ))
        }
        if( grepl( "CTD_END_LONGITUDE =", line ) ){
          lon_e <- as.numeric(sub("CTD_END_LONGITUDE =", "", line ))
        }

        if(grepl("CTDPRS", line)){break}
      }
      close(f)

      times = as.POSIXct(c(paste(date,time_s), paste(date,time_b), paste(date,time_e)), format = "%Y-%m-%d %H:%M:%S", tz = "UTC")
      # check forward in time, if not add 24 hrs as likely crossed days. 
      # bottom and end CTD time information
      if(!is.na(times[2]) & !is.na(times[1])){
        t_diff_b = difftime(times[2], times[1], units = "secs")
        if(t_diff_b < 0){times[2] = times[2] + (3600*24)
        t_diff_b = difftime(times[2], times[1], units = "secs")}
        }else{t_diff_b = NA}
      if(!is.na(times[3])& !is.na(times[1])){
        t_diff_e = difftime(times[3], times[1], units = "secs")
        if(t_diff_e < 0){times[3] = times[3] + (3600*24)
        t_diff_e = difftime(times[3], times[1], units = "secs")}
        }else{t_diff_e = NA}
      
      # bottom and end CTD pos information
      if(!is.na(lat_b) & !is.na(lon_b)){
        pos_diff_b = distGeo(c(lon, lat), c(lon_b,lat_b))
      }else{pos_diff_b = NA}
      if(!is.na(lat_e) & !is.na(lon_e)){
        pos_diff_e = distGeo(c(lon, lat), c(lon_e,lat_e))
      }else{pos_diff_e = NA}
      
      
      prof_data = as.data.frame(fread(ctd_file,strip.white = T , stringsAsFactors = F, skip = n+1,na.strings =  "-999"))
      f_headers = as.character(fread(ctd_file,stringsAsFactors = F, skip = n-1, nrows = 1, header = F))
      colnames(prof_data) = f_headers
      # convert to depth
      prof_data$DEPTH = swDepth(prof_data$CTDPRS, latitude = lat)
      prof_data = prof_data %>% filter(is.finite(DEPTH))
      if(any(grepl("CTDSAL",f_headers))){prof_data$CTDSAL = as.numeric(prof_data$CTDSAL)}
      if(any(grepl("CTDTMP",f_headers))){prof_data$CTDTMP = as.numeric(prof_data$CTDTMP)}
      
      if(any(grepl("CTDSAL",f_headers)) & any(grepl("CTDTMP",f_headers))){
        sdx = which(is.finite(prof_data$CTDSAL) & is.finite(prof_data$CTDTMP))
        if(length(sdx) > 0 ){
        DEPTH_s = prof_data$DEPTH[sdx[1]]}else{DEPTH_s = NA}
        }else{sdx = 1}
    if(any(grepl("CTDSAL",f_headers)) & any(!is.na(prof_data$CTDSAL))){
      CTDSAL_s = prof_data$CTDSAL[sdx[1]]
      if(prof_data$DEPTH[which(is.finite(prof_data$CTDSAL))][1]<10 & prof_data$DEPTH[which(is.finite(prof_data$CTDSAL))][length(prof_data$DEPTH[which(is.finite(prof_data$CTDSAL))])] >10){
        CTDSAL_10 = approx(prof_data$DEPTH[which(is.finite(prof_data$CTDSAL))], prof_data$CTDSAL[which(is.finite(prof_data$CTDSAL))],10)$y  
      }

    }else{CTDSAL_s = NA
      CTDSAL_10 = NA}
    if(any(grepl("CTDTMP",f_headers))& any(!is.na(prof_data$CTDTMP))){
      CTDTEMP_s = prof_data$CTDTMP[sdx[1]]
      if(prof_data$DEPTH[which(is.finite(prof_data$CTDTMP))][1]<10 & prof_data$DEPTH[which(is.finite(prof_data$CTDTMP))][length(prof_data$DEPTH[which(is.finite(prof_data$CTDTMP))])] >10){
        CTDTEMP_10 = approx(prof_data$DEPTH[which(is.finite(prof_data$CTDTMP))], prof_data$CTDTMP[which(is.finite(prof_data$CTDTMP))],10)$y
      }
    }else{CTDTEMP_s = NA
    CTDTEMP_10 = NA}

    ### MLD calculation - 0.03 density threshold - this is a typical definition of MLD for the SO
    if(all(any(grepl("CTDPRS",f_headers)), any(grepl("CTDSAL",f_headers)), any(grepl("CTDTMP",f_headers)),!is.na(lat)) & length(which(prof_data$DEPTH[is.finite(prof_data$DEPTH) & is.finite(prof_data$CTDSAL) & is.finite(prof_data$CTDTMP)] > 10)) >= 2){
      MLD_calc = MLD(prof_data$CTDPRS,prof_data$CTDSAL, prof_data$CTDTMP,lat = lat,dens_thresh = 0.03)
      MLD_n = MLD_calc$MLD
      MLD_FLAG = MLD_calc$FLAG
    }else{MLD_n = NA
    MLD_FLAG = NA}


      # gather ctd information
      CTD_df = CTD_df %>% add_row(CTD_ID = ctd, DATE = date, TIME_s = times[1], TIME_b= times[2], TIME_e= times[3], LAT = lat, LON = lon, LAT_b = lat_b, LON_b = lon_b, LAT_e = lat_e, LON_e = lon_e, T_diff_b = t_diff_b, T_diff_e = t_diff_e, POS_diff_b = pos_diff_b, POS_diff_e = pos_diff_e, BOT_DEPTH = max(prof_data$DEPTH, na.rm = T),DEPTH_s = DEPTH_s, CTDSAL_s = CTDSAL_s, CTDTEMP_s = CTDTEMP_s, CTDSAL_10 = CTDSAL_10, CTDTEMP_10 = CTDTEMP_10, MLD = MLD_n, MLD_FLAG = MLD_FLAG)

      }



```



```{r}
 t_thresh = 6
 d_thresh = 1000
  # this small function prevents the drop of midnight 00:00:00
  calc.dist.min = function(x){
   mins = which.min(distGeo(c(unmatched_df_p$LON_analyser[x], unmatched_df_p$LAT_analyser[x]), as.matrix(CTD_df[,c("LON","LAT")])))[1]
   dists = distGeo(c(unmatched_df_p$LON_analyser[x], unmatched_df_p$LAT_analyser[x]), as.matrix(CTD_df[mins,c("LON","LAT")]))
   if(any(!is.na(CTD_df$LON_b))){
     minb = which.min(distGeo(c(unmatched_df_p$LON_analyser[x], unmatched_df_p$LAT_analyser[x]), as.matrix(CTD_df[,c("LON_b","LAT_b")])))[1]
     mins = c(mins, minb)
     distb = distGeo(c(unmatched_df_p$LON_analyser[x], unmatched_df_p$LAT_analyser[x]), as.matrix(CTD_df[minb,c("LON_b","LAT_b")]))
     dists = c(dists, distb)}
   if(any(!is.na(CTD_df$LON_e))){
     mine = which.min(distGeo(c(unmatched_df_p$LON_analyser[x], unmatched_df_p$LAT_analyser[x]), as.matrix(CTD_df[,c("LON_e","LAT_e")])))[1]
     mins = c(mins, mine)
     diste = distGeo(c(unmatched_df_p$LON_analyser[x], unmatched_df_p$LAT_analyser[x]), as.matrix(CTD_df[mine,c("LON_e","LAT_e")]))
     dists = c(dists, diste)}
     data.frame(min = mins[which.min(dists)],diff = dists[which.min(dists)])
     }
  #calc.dist.diff = function(x){distGeo(c(unmatched_df_p$LON[x], unmatched_df_p$LAT[x]), as.matrix(CTD_df[unmatched_df_p$dist_min[x],c("LON","LAT")]))}
  calc.time.min = function(x){which.min(abs(unlist(lapply(col_t, FUN = function(y){difftime(CTD_df[,y], unmatched_df_t$time_m[x], units = "secs")}))))[1]}
  calc.time.diff =  function(x){abs(unlist(lapply(col_t, FUN = function(y){difftime(CTD_df[,y], unmatched_df_t$time_m[x], units = "secs")})))[unmatched_df_t$closest_t[x]]}


# CTD data exists?. Closest position and closest times?
pig_data$PROF_data = NA
pig_data$d_diff = NA
pig_data$t_diff = NA
for(ex in pig_expos){
    sub_prof_files = prof_files[which(substr(prof_files,1,12) == ex)]
    sub_pig_data = pig_data %>% filter(EXPOCODE == ex) %>% mutate(STNCAST = paste(STNNBR_analyser,CASTNO_analyser))
    data2_stncast = paste(sub_pig_data$STNNBR_analyser,sub_pig_data$CASTNO_analyser)
    sub_pig_data = sub_pig_data[!duplicated(sub_pig_data$STNCAST),]
    
    pig_data$PROF_data[which(pig_data$EXPOCODE == ex)] = length(sub_prof_files) != 0
    CTD_df_sub = CTD_df %>% filter(substr(prof_files,1,12) == ex)
    
    if(length(sub_prof_files) > 0){
      # ctd_ids from CTD files
      CTD_IDs = unlist(strsplit(sub_prof_files,"_ctd1.csv"))
      # create a data frame with split info
      ctd_split = strsplit(CTD_IDs, split = "_")
      CTD_info = data.frame("CTD_ID" = CTD_IDs, "EXPOCODE" = sapply(ctd_split, "[[", 1), "STNNBR" = sapply(ctd_split, "[[", 3), "CASTNO"= sapply(ctd_split, "[[", 4), stringsAsFactors = F)

  
      unmatched_df_t = sub_pig_data %>% filter(!is.na(TIME_analyser), !is.empty(TIME_analyser), !is.empty(DATE_analyser)) 
      unmatched_df_t = unmatched_df_t[,c(1:64,67)] %>%
        mutate(time_m = as.POSIXct(paste(DATE_analyser,TIME_analyser), format = "%Y-%m-%d %H:%M:%S", tz = "UTC"))
      notime = ifelse(nrow(unmatched_df_t) == 0,T,F)
      unmatched_df_p = sub_pig_data %>% filter(!is.na(LAT_analyser))
      unmatched_df_p = unmatched_df_p[,c(1:64,67)]
      nopos = ifelse(nrow(unmatched_df_p) == 0,T,F)
      if(!nopos){
        ### match closest times
        col_t = c(3:5)[!colSums(is.na(CTD_df_sub[3:5])) == nrow(CTD_df_sub)]
        if(!notime){
        #calculate time differences
        unmatched_df_t$closest_t = unlist(lapply(1:nrow(unmatched_df_t), calc.time.min))
        unmatched_df_t$t_diff = unlist(lapply(1:nrow(unmatched_df_t), calc.time.diff))

          # check it is within 3 hours and assign CTD_ID
          unmatched_df_t = unmatched_df_t %>% filter(!is.na(closest_t), t_diff < t_thresh)

          # Any matches?
          if(nrow(unmatched_df_t) > 0){
            # get CTD_IDs
            unmatched_df_t$CTD_ID = unlist(lapply(1:nrow(unmatched_df_t),function(x){r = CTD_df_sub$CTD_ID[unmatched_df_t$closest_t[x]%%nrow(CTD_df_sub)]
            if(is.empty(r)){r = CTD_df_sub$CTD_ID[nrow(CTD_df_sub)]}
            return(r)}))
            # join with data 2 IDs
            joined_t = left_join(data.frame("STNCAST" = data2_stncast),unmatched_df_t , by = "STNCAST")
          }}


        ### match closest positions

        # match with closest lat/lon on same date
        d_calc = lapply(1:nrow(unmatched_df_p), calc.dist.min)
        unmatched_df_p$dist_min  = unlist(lapply(d_calc,"[","min"))
        unmatched_df_p$d_diff = unlist(lapply(d_calc,"[","diff"))
        # check within distance threshold
        #unmatched_df_p  = unmatched_df_p %>% filter(d_diff < d_thresh)


        # Any matches?

        if(nrow(unmatched_df_p) > 0 & notime){
          # if no time matches consider date of position matches.
            unmatched_df_p = unmatched_df_p %>% mutate(Date_match = ifelse(DATE_analyser == CTD_df_sub$DATE[dist_min],T,F))
            unmatched_df_p = unmatched_df_p %>% filter(Date_match)
          }
        if(nrow(unmatched_df_p) > 0){
          # get CTD_ID
          unmatched_df_p$CTD_ID = unlist(lapply(1:nrow(unmatched_df_p),function(x){CTD_df_sub$CTD_ID[unmatched_df_p$dist_min[x]]}))
          # join with data 2 IDs
          joined_p = left_join(data.frame("STNCAST" = data2_stncast),unmatched_df_p[,64:65] , by = c("STNCAST"))
          if(exists("joined_t")){
           # join with data 2 IDs
           ## needs unique join columns. need to check if OK in PIG_to_WHPE
          joined_t_p = left_join(joined_t,unmatched_df_p[,c("STNCAST","dist_min","d_diff")] , by = "STNCAST")
          rm(joined_t)
          }else{joined_t_p = joined_p
          rm(joined_p)}
          }
             
      if(any(grepl(pattern = "d_diff", colnames(joined_t_p)))){
        pig_data$d_diff[pig_data$EXPOCODE == ex] = joined_t_p$d_diff
      }  
      if(any(grepl(pattern = "t_diff", colnames(joined_t_p)))){
        pig_data$t_diff[pig_data$EXPOCODE == ex] = joined_t_p$t_diff}
        rm(joined_t_p)
}}}
```



# data descriptions
```{r}
# row 1 = All, row 2 = subsurface profiles (>4 obs), row 3 = surface (<10 m)
# to add POC
data_description = data.frame("voyages", "Records", "Unique",  "PhysicalMatches", "CTD", "PIG","HPLC", "Fluor", "Both", "CTDFluor", "CTDbbp", "CTDcp")

# number of pig records

# number of pig profiles

# number of surface pigs

# number of prof profiles

# number of matches

# number of fluor profiles

# number of pig records



# 

```

# SO distribution plots of PROF, HPLC, FLUOR. Include histogram of temporal spread. Can produce an animation for supporting material. Total numbers displayed somewhere

# Histograms (Chl, Sal, Temp)

# Difference between surface physical measurements and PROF meadurements

# Fluor vs HPLC

# prediction of bottom, and CTD end times from start time, deepest depth and (maybe)n_pigment obs. 
